
# 作業を確認したブラウザ
  
  User-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36
  
# 技術的な決定

## フロントエンドとバックエンドの分離

バックエンド処理はグラフ描画処理であり、それらは全て `chart` ディレクトリ配下にまとめた。
フロントエンド処理は `views.py` にまとめ、`chart` 配下の機能を呼び出す形にすることでバックエンドと分離している。


## モデル定義

Consumption テーブルのフィールド `consumption` の型は `FloatField` とした。
理由は処理速度を優先するためである。

本アプリケーションでは数値の厳密さは重要ではないため、
処理速度を落としてまで `DecimalField` を選択する必要は無いと考えられる。


## インポート処理

データ量が多いため、バッチ処理でレコードの追加・更新を行うようにしている。

### 問題

時間の都合上、データベースに登録しようとしているCSVデータと同じ主キーのレコードが存在する場合、
それらに対して一律で上書きするようにした。
データベースへの負荷を考えると、登録前に各レコードのフィールドまでチェックして、
フィールドが異なる場合のみ更新するようにしたほうが良い。

また、テストを書いてデータベース登録前の前処理が期待通り実装できているかチェックしたかったが、
こちらも時間の都合上見送った。


## データ取得

極力データベース側で処理を行い、処理後の結果をアプリケーションで取得するようにした。
理由は、トラフィックの占有を防ぐためである。

例えば、消費量 (consumption) のデータ数は `ユーザ数 x 日数 x 48個/日` であり、テストデータだけでも50万個近くにのぼる。
消費量の統計量を計算しようとしたとき、アプリケーション側でこれを行うと消費量の全データを取得する必要があり、トラフィックを占有してしまうことが予想される。

そのため、データベース側で先に処理を行い、処理後の結果を取得するようにした。

データベース側の処理負荷について考えると、
今回のアプリケーションは大人数で使用するものでは無いため、
負荷については問題にならないと判断した。

### 問題

データベース側で統計量 (中央値、10-90%-ile) の計算をするために生のSQLを発行している。
保守性や脆弱性を考えると極力ORMの機能を活用すべきだと考えられる。

時間の都合上実装できなかったが、
Aggregate を継承することで実装している例も見つかったため、Django の機能だけで実装することは可能かもしれない。
https://gist.github.com/mekicha/b3d5e61683d5a6af642e4549eed95994


## summary ページ

ユーザーのリストアップはユーザー ID のみにした。
理由は、トラフィックの占有を防ぐためと、描画の高速化のためである。

仮にページネーションと非同期処理を組み合わせて一部のユーザー情報だけを表示する方針であれば、
ユーザーの全情報をテーブルで表示しても問題ないと考えられる。

しかし、今回は時間の都合上そこまで実装できなかったため、ユーザーIDのみを表示する方針とした。
